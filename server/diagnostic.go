package server

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"

	"github.com/corymhall/pulumilsp/file"
	"github.com/corymhall/pulumilsp/lsp"
)

type DiagnosticSource string

// A Diagnostic corresponds to an LSP Diagnostic.
// https://microsoft.github.io/language-server-protocol/specification#diagnostic
//
// It is (effectively) gob-serializable; see {encode,decode}Diagnostics.
type Diagnostic struct {
	URI      lsp.DocumentURI // of diagnosed file (not diagnostic documentation)
	Range    lsp.Range
	Severity lsp.DiagnosticSeverity
	Code     string // analysis.Diagnostic.Category (or "default" if empty) or hidden go/types error code
	CodeHref string

	// Source is a human-readable description of the source of the error.
	// Diagnostics generated by an analysis.Analyzer set it to Analyzer.Name.
	Source DiagnosticSource

	Message string
	Data    *json.RawMessage

	// Tags    []protocol.DiagnosticTag
	// Related []protocol.DiagnosticRelatedInformation

}

// Hash computes a hash to identify the diagnostic.
// The hash is for deduplicating within a file, so does not incorporate d.URI.
func (d *Diagnostic) Hash() file.Hash {
	h := sha256.New()
	// for _, t := range d.Tags {
	// 	fmt.Fprintf(h, "tag: %s\n", t)
	// }
	// for _, r := range d.Related {
	// 	fmt.Fprintf(h, "related: %s %s %s\n", r.Location.URI, r.Message, r.Location.Range)
	// }
	fmt.Fprintf(h, "code: %s\n", d.Code)
	fmt.Fprintf(h, "codeHref: %s\n", d.CodeHref)
	fmt.Fprintf(h, "message: %s\n", d.Message)
	fmt.Fprintf(h, "range: %s\n", d.Range)
	fmt.Fprintf(h, "severity: %s\n", d.Severity)
	fmt.Fprintf(h, "source: %s\n", d.Source)
	if d.Data != nil {
		fmt.Fprintf(h, "fixes: %s\n", *d.Data)
	}
	var hash [sha256.Size]byte
	h.Sum(hash[:0])
	return hash
}
